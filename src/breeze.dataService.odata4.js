(function (definition, global) {
  var factory = function (breeze) {
    return definition(breeze, global);
  };

  if (typeof breeze === "object") {
    factory(breeze);
  } else if (typeof require === "function" && typeof exports === "object" && typeof module === "object") {
    // CommonJS or Node: hard-coded dependency on "breeze"
    factory(require("breeze"));
  } else if (typeof define === "function" && define["amd"]) {
    // AMD anonymous module with hard-coded dependency on "breeze"
    define(["breeze"], factory);
  }
}(function (breeze, global) {
  "use strict";

  var core = breeze.core;

  var MetadataStore = breeze.MetadataStore;
  var JsonResultsAdapter = breeze.JsonResultsAdapter;
  var DataProperty = breeze.DataProperty;
  var NavigationProperty = breeze.NavigationProperty;
  var AutoGeneratedKeyType = breeze.AutoGeneratedKeyType;
  var DataType = breeze.DataType;

  var ODataContentType = "application/json;IEEE754Compatible=true"   // breeze serializes decimals and Int64s as strings

  var odatajs;

  var ctor = function DataServiceODataV4Adapter() {
    this.name = "ODataV4";
  };

  var proto = ctor.prototype; // minifies better (as seen in jQuery)

  proto.initialize = function () {
    odatajs = core.requireLib("odatajs", "Needed to support remote OData services");
  };
  // borrow from AbstractDataServiceAdapter
  var abstractDsaProto = breeze.AbstractDataServiceAdapter.prototype;
  proto._catchNoConnectionError = abstractDsaProto._catchNoConnectionError;
  proto.changeRequestInterceptor = ODataV4ChangeRequestInterceptor;
  proto._createChangeRequestInterceptor = abstractDsaProto._createChangeRequestInterceptor;
  proto.headers = { "OData-Version": "4.0", "Accept": ODataContentType };
  proto.executeQuery = function (mappingContext) {

    var self = this;
    var headers = {};
    core.extend(headers, this.headers);
    if (mappingContext.query.parameters && mappingContext.query.parameters._headers) {
      core.extend(headers, mappingContext.query.parameters._headers);
      delete mappingContext.query.parameters._headers;    // Don't pass it too as additional parameters
    }

    var deferred = breeze.Q.defer();
    var url = mappingContext.getUrl();

    odatajs.oData.read({
      requestUri: url,
      headers: headers
    },
    function (data, response) {
      var inlineCount;
      if (data['@odata.count']) {
        // OData can return data['@odata.count'] as a string
        inlineCount = parseInt(data['@odata.count'], 10);
      }
      // Start our custom tracking of np changes
      var manager = mappingContext.entityManager;
      if (!manager.__trackingNPs) { // Don't subscribe more than once
        manager.entityChanged.subscribe(function (e) {
          if (e.entityAction === breeze.EntityAction.PropertyChange && !e.entity.entityAspect.entityState.isAdded()) {
            if (e.args.property.isNavigationProperty) {
              var originalValues = e.entity.entityAspect.originalValues,
                  npName = e.args.property.name;
              originalValues[npName] = originalValues[npName] || e.args.oldValue;
            }
          }
          if (e.entityAction === breeze.EntityAction.AttachOnQuery && !e.entity.entityType.defaultResourceName && !e.entity.entityAspect.extraMetadata.uriKey) {
            // The entity is contained, so store now the uriKey in case it's later deleted and loses it's reference to it's container.
            // We can't wait until it's deleted, it's too late by then
            try {
              e.entity.entityAspect.extraMetadata.uriKey = getUriKey(e.entity.entityAspect);
            }
            catch (ex) {
              // So the container is not attached yet. Try again when it is.
              var eventToken = manager.entityChanged.subscribe(function (pe) {
                if (pe.entityAction === breeze.EntityAction.AttachOnQuery) {
                  try {
                    e.entity.entityAspect.extraMetadata.uriKey = getUriKey(e.entity.entityAspect);
                  }
                  catch (pex) { return; }
                  // We only need to do this once per entity.
                  // BUG? If we unsubscribe inside the event handler, the next handler won't run...
                  setTimeout(function () { manager.entityChanged.unsubscribe(eventToken); });
                }
              });
            }
          }
        });
        manager.__trackingNPs = true;
      }
      // OData singletons are returned directly in the root
      return deferred.resolve({ results: data.value || [data], inlineCount: inlineCount, httpResponse: response });
    },
    function (error) {
      return deferred.reject(self.parseError(error, url, mappingContext));
    });

    return deferred.promise;
  };


  proto.fetchMetadata = function (metadataStore, dataService) {

    var self = this;
    var deferred = breeze.Q.defer();

    var serviceName = dataService.serviceName;
    var url = dataService.qualifyUrl('$metadata');
    odatajs.oData.read({
      requestUri: url,
      headers: { Accept: 'application/json;odata.metadata=full' }
    },
        function (data) {
          // data.dataServices.schema is an array of schemas. with properties of
          // entityContainer[], association[], entityType[], and namespace.
          if (!data || !data.dataServices) {
            var error = new Error("Metadata query failed for: " + url);
            return deferred.reject(error);
          }
          var csdl = data.dataServices;
          fixCsdlForBreezeParser(csdl);
          
          // might have been fetched by another query
          if (!metadataStore.hasMetadataFor(serviceName)) {
            try {
              metadataStore.importMetadata(csdl);
            } catch (e) {
              return deferred.reject(new Error("Metadata query failed for " + url + "; Unable to process returned metadata: " + e.message));
            }

            fixMetadataAfterBreezeParser(metadataStore, csdl);

            metadataStore.addDataService(dataService);
          }

          return deferred.resolve(csdl);

        }, function (error) {
          var err = self.parseError(error, url);
          err.message = "Metadata query failed for: " + url + "; " + (err.message || "");
          return deferred.reject(err);
        },
        odatajs.oData.metadataHandler
    );

    return deferred.promise;

    function fixCsdlForBreezeParser(csdl) {
      // The base CsdlParser used inside the MetadataStore has a number of quirks and behaviors from OData V3
      // that *almost* match what we need for V4. Almost.

      var containerSchema = csdl.schema.filter(function (schema) { return schema.entityContainer; })[0];

      containerSchema.entityContainer.associationSet = containerSchema.entityContainer.associationSet || [];

      // Fix the key properties for the entities
      csdl.schema.forEach(function (schema) {
        schema.entityType && schema.entityType
          .filter(function (et) { return !!et.key; })
          .forEach(function (et) {
            // TODO: Yes, the parser expects that "key" is a single key and not an array. We need a better fix/parser.
            if (et.key.length > 1) { throw new Error("Entities with composite keys are not supported right now."); }
            et.key = et.key[0];
          });
      });

      // Fix the navigation properties
      csdl.schema.forEach(function (schema) {
        schema.association = schema.association || [];
        schema.entityType && schema.entityType.forEach(function (et) {
          // The parser expects that an association exist for every relationship between entities.
          et.navigationProperty && et.navigationProperty
            .filter(function (np) { return !np.relationship; })
            .forEach(function (np) {

              var posibilities = getPossibleAssociations(et, np, schema);
              var association = schema.association.find(function (sa) { return posibilities.some(function (a) { return sa.name === a.name; }); });

              // The association doesn't exist. Create it.
              if (!association) {
                association = posibilities[0];

                schema.association.push(association);
                containerSchema.entityContainer.associationSet.push({
                  association: association.name
                })

                np.relationship = schema.namespace + "." + association.name;
                np.fromRole = association.end[0].role;
                np.toRole = association.end[1].role;
              }
              else {
                np.relationship = schema.namespace + "." + association.name;
                np.fromRole = association.end[1].role;
                np.toRole = association.end[0].role;
              }
            });
        });
      });

      // Remove the "Collection([Type])" syntax, which breeze chokes on. We'll fix it later
      csdl.schema.forEach(function (schema) {
        [].concat(schema.entityType, schema.complexType)
          .filter(function (t) { return !!t; })
          .forEach(function (t) {
            t.property && t.property
              .filter(function (p) { return isCollection(p.type); })
              .forEach(function (p) {
                p.isCollection = true;
                p.type = p.type.replace(/Collection\(([^)]+)\)/, "$1");
              });
          });
      });

      // Map type definitions to their underlying base type
      var typeDefinitions = {};
      csdl.schema.forEach(function (schema) {
        schema.typeDefinition && schema.typeDefinition.forEach(function (td) {
          typeDefinitions[schema.namespace + "." + td.name] = td;
        });
      });
      csdl.schema.forEach(function (schema) {
        [].concat(schema.entityType, schema.complexType)
          .filter(function (t) { return !!t; })
          .forEach(function (t) {
            t.property && t.property.forEach(function (p) {
              var td;
              // A type definition can have another one as it's underlying type.
              // That's why we have to go to the base one
              while (td = typeDefinitions[p.type]) {
                // Keep the original type
                p.typeDefinition = p.typeDefinition || p.type;
                // Replace the type name
                p.type = td.underlyingType;
                // Also merge facets and annotations of the type definition
                for (var attr in td) {
                  if (['name', 'underlyingType'].indexOf(attr) >= 0) continue;

                  p[attr] = p[attr] || td[attr];
                }
              }
            });
          });
      });
    }
    function getPossibleAssociations(entityType, csdlProperty, schema) {
      // All associations are simply named as "[SourceRole]_[PartnerRole]"
      // The role is given by the partner property's name.
      // The order can vary. If one side of the relation is Many and the other is One, the One side is
      // the source and goes first.
      // Otherwise, it could go either way.

      var relatedTypeName = csdlProperty.type.replace(/Collection\(([^)]+)\)/, "$1").split(".").pop(),
          relatedType = schema.entityType.filter(function (et) { return et.name === relatedTypeName; })[0];

      if (csdlProperty.partner) {
        var partner = relatedType.navigationProperty.filter(function (np) { return np.name === csdlProperty.partner; })[0],
            thisRole = csdlProperty.partner,
            partnerRole = csdlProperty.name;

        // TODO: only one possibility if the multiplicities are asymetrical.
        return [
          {
            name: thisRole + "_" + partnerRole,
            end: [
              { multiplicity: isCollection(partner.type) ? "*" : "1", role: thisRole, type: schema.namespace + "." + entityType.name },
              { multiplicity: isCollection(csdlProperty.type) ? "*" : "1", role: partnerRole, type: schema.namespace + "." + relatedType.name }
            ]
          },
          {
            name: partnerRole + "_" + thisRole,
            end: [
              { multiplicity: isCollection(csdlProperty.type) ? "*" : "1", role: partnerRole, type: schema.namespace + "." + relatedType.name },
              { multiplicity: isCollection(partner.type) ? "*" : "1", role: thisRole, type: entityType.name }
            ]
          }
        ]
      }
      else {
        // If there's no partner, meaning it's a one-way relationship, we use "[ThisType]_[PropertyName]"
        // (ie.: "Contract_Bindings")
        return [{
          name: entityType.name + "_" + csdlProperty.name,
          end: [
            { multiplicity: "*", role: entityType.name, type: schema.namespace + "." + entityType.name },
            { multiplicity: isCollection(csdlProperty.type) ? "*" : "1", role: csdlProperty.name, type: schema.namespace + "." + relatedType.name }
          ]
        }];
      }
    }

    function fixMetadataAfterBreezeParser(metadataStore, csdl)
    {
      // There's only so much we can fix in the CSDL.

      // The parser ignored many-to-many relations without referential constraints. We don't like that.
      csdl.schema.forEach(function (schema) {
        schema.entityType && schema.entityType.forEach(function (csdlType) {
          csdlType.navigationProperty && csdlType.navigationProperty.forEach(function (csdlProperty) {
            var association = schema.association.filter(function(a) { return csdlProperty.relationship === schema.namespace + "." + a.name; })[0];
            if (association.end.every(function (end) { return end.multiplicity === "*"; })) {

              var entityType = metadataStore.getEntityType(getQualifiedName(csdlType.name, schema.namespace)),
                  toEnd = association.end.filter(function (end) { return end.role === csdlProperty.toRole; })[0],
                  partnerType = csdlProperty.partner ? metadataStore.getEntityType(getQualifiedName(toEnd.type)) : null,
                  partner = partnerType && partnerType.getNavigationProperty(metadataStore.namingConvention.serverPropertyNameToClient(csdlProperty.partner)),
                  np = new NavigationProperty({
                    nameOnServer: csdlProperty.name,
                    entityTypeName: getQualifiedName(toEnd.type),
                    isScalar: false,
                    associationName: association.name
                  });

              entityType.addProperty(np);

              if (partner && !partner.inverse) {
                // Resolve the inverse property in the partner (it would already be resolved if
                // we used foreign keys...)
                partner._resolveNp();
              }

            }
          });
        });
      });

      // Breeze can't merge any-to-many NPs when parsing query requests if the NP doesn't have an inverse
      // (Check mergeRelatedEntities)
      // To work around it, we create a shim inverse NP. We never serialize it back to the server, though.
      csdl.schema.forEach(function (schema) {
        schema.entityType && schema.entityType.forEach(function (csdlType) {
          csdlType.navigationProperty && csdlType.navigationProperty.forEach(function (csdlProperty) {
            if (csdlProperty.partner) { return; }
            var association = schema.association.filter(function (a) { return csdlProperty.relationship === schema.namespace + "." + a.name; })[0],
                toEnd = association.end.find(function (end) { return end.role === csdlProperty.toRole; });
            if (toEnd.multiplicity === "*") {
              // We must do this for every sub-type that's already declared too.
              metadataStore.getEntityType(getQualifiedName(toEnd.type)).getSelfAndSubtypes()
                .forEach(function (t) {
                  var np = new NavigationProperty({
                    name: '$' + association.name,
                    entityTypeName: getQualifiedName(csdlType.name, schema.namespace),
                    isScalar: association.end.find(function (end) { return end !== toEnd; }).multiplicity === "*" ? false : true,
                    associationName: association.name
                  });

                  t.addProperty(np);
                  np.inverse._resolveNp();
                });
            }
          });
        });
      });

      // Fix the typenames associated with each resource (entity set in odata parlance)
      // The parser used the container's namespace (ie.: http://example.com/api) as the entity's,
      // when it should have used the entity's schema.
      csdl.schema.forEach(function (schema) {
        schema.entityContainer && schema.entityContainer.entitySet.forEach(function (entitySet) {
          // In the entitySet, the typeName is fully qualified but not in the way breeze likes.
          metadataStore.setEntityTypeForResourceName(entitySet.name, getQualifiedName(entitySet.entityType));
        });
      });

      // OData V4 uses an annotation to mark identity key properties.
      // The parser expected the V3 way.
      csdl.schema.forEach(function (schema) {
        schema.annotations && schema.annotations.forEach(function (annotations) {
          if (!annotations.annotation.some(function (a) { return a.term === "Org.OData.Core.V1.Computed" && a.bool; })) { return; /* Not the annotation we're looking for. */ }

          var targetPath = annotations.target.split("/"), // target be like "Namespace.EntityType/PropertyName/SubProperty"
              entityTypeName = getQualifiedName(targetPath.shift()),
              entityType, property,
              currentName, currentType;

          if (!targetPath.length) { return; /* Not for a property. */ }

          entityType = metadataStore.getEntityType(entityTypeName, true);
          if (!entityType) { return; /* Not for an entity's property. */ }

          currentType = entityType;
          while (currentName = targetPath.shift()) {
            property = currentType.getProperty(metadataStore.namingConvention.serverPropertyNameToClient(currentName));
            currentType = property.dataType;
          }

          if (property.isPartOfKey) {
            // Bingo!
            entityType.getSelfAndSubtypes().forEach(function (et) {
              et.autoGeneratedKeyType = AutoGeneratedKeyType.Identity;
            });
          }

        });
      });

      // OData complex types can actually be nullable!
      csdl.schema.forEach(function (schema) {
        schema.entityType && schema.entityType.forEach(fixNullableComplexProperties, schema);
        schema.complexType && schema.complexType.forEach(fixNullableComplexProperties, schema);
      });
      function fixNullableComplexProperties(csdlType) {
        var schema = this,
            type = null,
            property;
        csdlType.property && csdlType.property.forEach(function (csdlProperty) {
          var isNullable = csdlProperty.nullable === 'true' || csdlProperty.nullable == null,
              property;
          if (!isNullable) { return; }

          type = type || metadataStore.getEntityType(getQualifiedName(csdlType.name, schema.namespace));
          property = type.getProperty(metadataStore.namingConvention.serverPropertyNameToClient(csdlProperty.name));
          if (!property.isComplexProperty) { return; }

          property.isNullable = isNullable;
        });
      }

      // Computed properties are not required actually
      csdl.schema.forEach(function (schema) {
        schema.annotations && schema.annotations.forEach(function (annotations) {
          if (!annotations.annotation.some(function (a) { return a.term === "Org.OData.Core.V1.Computed" && a.bool; })) { return; /* Not the annotation we're looking for. */ }

          var targetPath = annotations.target.split("/"), // target be like "Namespace.EntityType/PropertyName/SubProperty"
              entityTypeName = getQualifiedName(targetPath.shift()),
              entityType, property,
              currentName, currentType;

          if (!targetPath.length) { return; /* Not for a property. */ }

          entityType = metadataStore.getEntityType(entityTypeName, true);
          if (!entityType) { return; /* Not for an entity's property. */ }

          currentType = entityType;
          while (currentName = targetPath.shift()) {
            property = currentType.getProperty(metadataStore.namingConvention.serverPropertyNameToClient(currentName));
            currentType = property.dataType;
          }

          var ix;
          // Remove any existing 'required' validator
          while ((ix = property.validators.findIndex(function (v) { return v.name === 'required'; })) >= 0) {
            property.validators.splice(ix, 1);
          }
        });
      });

      // Restore collections removed in "fixForCsdlParser"
      csdl.schema.forEach(function (schema) {
        schema.entityType && schema.entityType.forEach(fixCollectionProperties, schema);
        schema.complexType && schema.complexType.forEach(fixCollectionProperties, schema);
      })
      function fixCollectionProperties(csdlType) {
        var schema = this,
            type = null,
            property;
        csdlType.property && csdlType.property
          .filter(function (p) { return p.isCollection; })
          .forEach(function (csdlProperty) {
            type = type || metadataStore.getEntityType(getQualifiedName(csdlType.name, schema.namespace));
            property = type.getProperty(metadataStore.namingConvention.serverPropertyNameToClient(csdlProperty.name));
            property.isScalar = false;
          });
      }

      function getQualifiedName(typeName, namespace) {
        var shortName = typeName.substring(typeName.lastIndexOf(".") + 1);
        namespace = namespace || typeName.substring(0, typeName.lastIndexOf("."));
        return shortName + ":#" + namespace;
      }
    }

    function isCollection(typeName) {
      return typeName.indexOf("Collection(") === 0;
    }
  };

  proto.getRoutePrefix = function (/*dataService*/) {
    return '';
  }; // see webApiODataCtor

  proto.saveChanges = function (saveContext, saveBundle) {
    var adapter = saveContext.adapter = this;
    var deferred = breeze.Q.defer();
    saveContext.routePrefix = adapter.getRoutePrefix(saveContext.dataService);
    var url = saveContext.dataService.qualifyUrl("$batch");

    var requestData = createChangeRequests(saveContext, saveBundle);
    var tempKeys = saveContext.tempKeys;
    var contentKeys = saveContext.contentKeys;

    odatajs.oData.request({
      headers: {
        "OData-Version": "4.0",
      },
      requestUri: url,
      method: "POST",
      data: requestData
    }, function (data, response) {
      var entities = [];
      var keyMappings = [];
      var saveResult = { entities: entities, keyMappings: keyMappings };
      data.__batchResponses.forEach(function (br) {
        br.__changeResponses.forEach(function (cr, index) {
          var response = cr.response || cr;
          var statusCode = response.statusCode;
          if ((!statusCode) || statusCode >= 400) {
            var requestUrl = saveContext.dataService.qualifyUrl(requestData.__batchRequests[0].__changeRequests[index].requestUri),
                ctx = core.extend({}, saveContext);
            ctx = core.extend(ctx, { contentId: index + 1 });
            deferred.reject(adapter.parseError(cr, requestUrl, ctx));
            return;
          }

          /**
           * It seems that the `Content-ID` header is not being properly parsed out by the odatajs library. As a work around
           * we can assume that each change response is numbered sequentially from 1, and infer the ID from the index in the
           * br.__changeResponses array.
           */
          //var contentId = cr.headers["Content-ID"];
          var contentId = index + 1;

          var rawEntity = cr.data;
          if (rawEntity) {
            var tempKey = tempKeys[contentId];
            if (tempKey) {
              var entityType = tempKey.entityType;
              if (entityType.autoGeneratedKeyType !== AutoGeneratedKeyType.None) {
                var tempValue = tempKey.values[0];
                var realKey = entityType.getEntityKeyFromRawEntity(rawEntity, DataProperty.getRawValueFromServer);
                var keyMapping = { entityTypeName: entityType.name, tempValue: tempValue, realValue: realKey.values[0] };
                keyMappings.push(keyMapping);
              }
              rawEntity.__metadata = {
                type: entityType.name
              }
            }
            entities.push(rawEntity);
          } else {
            var origEntity = contentKeys[contentId];
            entities.push(origEntity);
          }
        });
      });
      return deferred.resolve(saveResult);
    }, function (err) {
      return deferred.reject(adapter.parseError(err, url, saveContext));
    }, odatajs.oData.batch.batchHandler);

    return deferred.promise;

  };

  proto.jsonResultsAdapter = new JsonResultsAdapter({
    name: "OData_default",

    visitNode: function (node, mappingContext, nodeContext) {
      var result = {};
      if (node == null) return result;
      var metadata = node.__metadata;

      if (!metadata) {
        if (node['@odata.type']) {
          metadata = {
            type: node['@odata.type'].substr(1)   // starts with '#'
          };
        }
        else if (["navProp", "navPropItem"].indexOf(nodeContext.nodeType) >= 0) {
          // @odata.type is only present if the node is a subtype of the expected type.
          metadata = {
            type: nodeContext.navigationProperty.entityTypeName
          };
        }
      }

      if (metadata != null) {
        // TODO: may be able to make this more efficient by caching of the previous value.
        var entityTypeName = MetadataStore.normalizeTypeName(metadata.type);
        var et = entityTypeName && mappingContext.entityManager.metadataStore.getEntityType(entityTypeName, true);
        // OData response doesn't distinguish a projection from a whole entity.
        // We'll assume that whole-entity data would have at least as many properties  (<=)
        // as the EntityType has mapped properties on the basis that
        // most projections remove properties rather than add them.
        // If not, assume it's a projection and do NOT treat as an entity
        if (et && (et._mappedPropertiesCount <= Object.keys(node).length - 1
          || !mappingContext.query || !mappingContext.query.selectClause
          || ["navProp", "navPropItem"].indexOf(nodeContext.nodeType) >= 0)) {
          // if (et && et._mappedPropertiesCount === Object.keys(node).length - 1) { // OLD
          result.entityType = et;

          var uriKey = metadata.uri || metadata.id;
          if (uriKey) {
            // Strip baseUri to make uriKey a relative uri
            // Todo: why is this necessary when absolute works for every OData source tested?
            var re = new RegExp('^' + mappingContext.dataService.serviceName, 'i');
            uriKey = uriKey.replace(re, '');
          }
          result.extraMetadata = {
            uriKey: uriKey,
            etag: metadata.etag
          }
        }
      }
      // OData v3 - projection arrays will be enclosed in a results array
      if (node.results) {
        result.node = node.results;
      }

      var propertyName = nodeContext.propertyName;
      result.ignore = node.__deferred != null || propertyName === "__metadata" ||
        // EntityKey properties can be produced by EDMX models
          (propertyName === "EntityKey" && node.$type && core.stringStartsWith(node.$type, "System.Data"));

      return result;
    }

  });


  function ODataV4ChangeRequestInterceptor(saveContext, saveBundle) {

    this.getRequest = function (request, entity, index) {

      request.__entity = entity;  // We use this data later

      // This is only for requests with content (ie.: not DELETE)
      if (!request.data) { return request; }

      var aspect = entity.entityAspect;

      // http://docs.oasis-open.org/odata/odata-json-format/v4.0/errata03/os/odata-json-format-v4.0-errata03-os-complete.html#_Toc453766630
      // The odata.type annotation must be present in request if, among others...
      // * The type is derived from the type specified for the (collection of) entities or (collection of) complex type instances.
      // Now, here we have no idea of what collection we are refering to, so to be sure, add for all subclasses
      if (entity.entityType.baseEntityType && !request.data.hasOwnProperty('@odata.type')) {
        request.data['@odata.type'] = '#' + entity.entityType.namespace + '.' + entity.entityType.shortName;
      }

      // OData complex types are nullable, but Breeze doesn't know :@
      entity.entityType.getProperties()
          .filter(function (prop) {
            // So get all the entities complex properties that are conceptually null
            return prop.isComplexProperty && prop.isScalar &&
                request.data[prop.nameOnServer] &&
                entity.getProperty(prop.name).complexAspect.isNull(); // TODO: No! This is for our own customization of breeze, and doesn't work with the default
          })
          .forEach(function (prop) {
            // and remove them from the request.
            request.data[prop.nameOnServer] = null;
          });

      // Use bind operations to set navigation properties
      // where the related entity already exists
      getChangedNavigationProperties(entity)
        .forEach(function (prop) {
          /* TODO: Had to actually patch odatajs for this to work
           *   var jsonSerializableMetadata = ["@odata.id", "@odata.type", "@odata.bind"];
           * otherwise it would strip this out of the request body. I want a cleaner, safer way to to this.
           */
          var related = entity.getProperty(prop.name),
              val;

          // Send NPs thru a bind operation. 
          // Here, we resolve the url.
          if (prop.isScalar) {
            if (related && !related.entityAspect.entityState.isAdded()) {
              val = getUriKey(related.entityAspect);
            }
          }
          else {
            val = related
                  .filter(function (e) { return !e.entityAspect.entityState.isAdded(); })
                  .map(function (e) { return getUriKey(e.entityAspect); });
            if (!val.length) { return };
          }

          request.data[prop.nameOnServer + '@odata.bind'] = val;
        });

      return request;
    };

    this.done = function (requests) {

      // Now that we have all the request in the batch, we can detect which ones must or can be
      // deep inserted.
      // Contained entities *must* be deep inserted along with their containers.
      // Other related added entities *should* be deep inserted along with their partner.
      requests.forEach(function (request) {
        var entity = request.__entity;
        if (entity.entityAspect.entityState.isAdded()) {
          getChangedNavigationProperties(entity)
            .forEach(function (prop) {
              var isContainedType = isContainedEntityType(prop.entityType);

              if (prop.isScalar) {
                var e = entity.getProperty(prop.name);
                if (e && (isContainedType || e.entityAspect.entityState.isAdded())) {
                  // Find the request avoiding cycles, put the data inside us, mark it for later removal
                  var subRequest = requests.find(function (r) { return r.__entity === e && r !== request.__nestedIn; });
                  if (subRequest) {
                    request.data[prop.nameOnServer] = subRequest.data;
                    subRequest.__nestedIn = request;
                  }
                }
              }
              else {
                entity.getProperty(prop.name)
                  .filter(function (e) { return isContainedType || e.entityAspect.entityState.isAdded(); })
                  .forEach(function (e) {
                    // Find the request avoiding cycles, put the data inside us, mark it for removal
                    var subRequest = requests.find(function (r) { return r.__entity === e && r !== request.__nestedIn; });
                    if (subRequest) {
                      request.data[prop.nameOnServer] = request.data[prop.nameOnServer] || [];
                      request.data[prop.nameOnServer].push(subRequest.data);
                      subRequest.__nestedIn = request;
                    }
                  })
              }
            });
        }
      });

      // Remove the intermediate data we added (we don't want to pass that to the serializer!)
      requests.forEach(function (request) { request.__entity = undefined; });

      // Remove all the sub requests
      // We do this after processing everyone to allow for deep-er-inserts (entities inside entities inside entities)
      var ix;
      while ((ix = requests.findIndex(function (r) { return r.__nestedIn; })) >= 0) {
        requests.splice(ix, 1);
      }
    };

    function getChangedNavigationProperties(entity) {
      var aspect = entity.entityAspect,
          stype = entity.entityType;

      return stype.getProperties()
        .filter(function (prop) { return prop.isNavigationProperty && !prop.name.startsWith("$"); })
        .filter(function (prop) {
          var currentValue = entity.getProperty(prop.name);
          
          if (aspect.entityState.isModified()) {
            if (aspect.originalValues[prop.name] !== undefined) {
              // We double check the value is actually different.
              // TODO: This doesn't work with collections.
              return !prop.isScalar || aspect.originalValues[prop.name] !== currentValue;
            }
          }
          else if (aspect.entityState.isAdded()) {
            // Any value is a new value
            return prop.isScalar && currentValue || !prop.isScalar && currentValue.length;
          }
        });
    }

    function isContainedEntityType(entityType) {
      return entityType.defaultResourceName === "*";
    }
        
  }


  function transformValue(prop, val) {
    if (prop.isUnmapped) return undefined;
    if (prop.isNavigationProperty) return undefined;
    if (prop.dataType === DataType.DateTimeOffset) {
      // The datajs lib tries to treat client dateTimes that are defined as DateTimeOffset on the server differently
      // from other dateTimes. This fix compensates before the save.
      val = val && new Date(val.getTime() - (val.getTimezoneOffset() * 60000));
    } else if (prop.dataType === DataType.Date) {
      val = prop.dataType.fmtOData(val);
    } else if (prop.dataType.quoteJsonOData) {
      val = val != null ? val.toString() : val;
    }
    return val;
  }

  function createChangeRequests(saveContext, saveBundle) {
    var changeRequestInterceptor = saveContext.adapter._createChangeRequestInterceptor(saveContext, saveBundle);
    var changeRequests = [];
    var tempKeys = [];
    var contentKeys = [];
    var entityManager = saveContext.entityManager;
    var helper = entityManager.helper;
    var id = 0;
    var routePrefix = saveContext.routePrefix;

    saveBundle.entities.forEach(function (entity, index) {
      var aspect = entity.entityAspect;
      id = id + 1; // we are deliberately skipping id=0 because Content-ID = 0 seems to be ignored.
      var request = { headers: { "Content-ID": id, "Content-Type": ODataContentType } };
      core.extend(request.headers, proto.headers);

      contentKeys[id] = entity;
      if (aspect.entityState.isAdded()) {
        request.requestUri = getUriKey(entity.entityAspect);
        request.requestUri = request.requestUri.indexOf('//') > 0 ? request.requestUri : routePrefix + request.requestUri;
        request.method = "POST";
        request.data = helper.unwrapInstance(entity, transformValue);
        tempKeys[id] = aspect.getKey();
      } else if (aspect.entityState.isModified()) {
        updateDeleteMergeRequest(request, aspect, routePrefix);
        request.method = "PATCH";
        request.data = helper.unwrapChangedValues(entity, entityManager.metadataStore, transformValue);
        // should be a PATCH/MERGE
      } else if (aspect.entityState.isDeleted()) {
        updateDeleteMergeRequest(request, aspect, routePrefix);
        request.method = "DELETE";
      } else {
        return;
      }

      // Add additional parameters from the save options
      var tag = saveBundle.saveOptions.tag || {},
          query = "", key;
      for (key in tag) {
        query += (query ? "&" : "?") + key + "=" + encodeURIComponent(tag[key]);
      }
      request.requestUri += query;

      request = changeRequestInterceptor.getRequest(request, entity, index);
      changeRequests.push(request);
    });
    saveContext.contentKeys = contentKeys;
    saveContext.tempKeys = tempKeys;
    changeRequestInterceptor.done(changeRequests);
    return {
      __batchRequests: [
          {
            __changeRequests: changeRequests
          }
      ]
    };

  }


  function updateDeleteMergeRequest(request, aspect, routePrefix) {
    var uriKey;
    var extraMetadata = aspect.extraMetadata = (aspect.extraMetadata || {});
    if (!extraMetadata.uriKey) {
      extraMetadata.uriKey = uriKey = getUriKey(aspect);
    }
    else {
      uriKey = extraMetadata.uriKey;
    }
    if (extraMetadata.etag) {
      request.headers["If-Match"] = extraMetadata.etag;
    }
    request.requestUri =
      // use routePrefix if uriKey lacks protocol (i.e., relative uri)
            uriKey.indexOf('//') > 0 ? uriKey : routePrefix + uriKey;
  }

  function getUriKey(aspect) {
    var entityType = aspect.entity.entityType;
    var uriKey = entityType.defaultResourceName;
    if (!uriKey) {
      // This entity is contained, thru some navProp
      uriKey = entityType.navigationProperties.reduce(function (prev, np) {
        if (prev) { return prev; }

        var relatedEntity = np.isScalar ? aspect.getPropertyValue(np) : aspect.getPropertyValue(np)[0];
        return relatedEntity && np.inverse && getUriKey(relatedEntity.entityAspect) + "/" + np.inverse.nameOnServer;
      }, null);
      if (!uriKey) throw new Error("Could not find parent of contained entity.")
    }
    if (!aspect.entityState.isAdded() || entityType.autoGeneratedKeyType === AutoGeneratedKeyType.None) {
      var kps = entityType.keyProperties;
      uriKey += "(";
      if (kps.length === 1) {
        uriKey = uriKey + fmtProperty(kps[0], aspect) + ")";
      } else {
        var delim = "";
        kps.forEach(function (kp) {
          uriKey = uriKey + delim + kp.nameOnServer + "=" + fmtProperty(kp, aspect);
          delim = ",";
        });
        uriKey = uriKey + ")";
      }
    }
    return uriKey;
  }

  function fmtProperty(prop, aspect) {
    return prop.dataType.fmtOData(aspect.getPropertyValue(prop.name));
  }

  proto.parseError = function parseError(error, url, requestContext) {
    var result = new Error();
    var response = error && error.response;
    if (!response) {
      // in case DataJS returns "No handler for this data"
      result.message = error;
      result.statusText = error;
      return result;
    }
    result.message = response.statusText;
    result.statusText = response.statusText;
    result.status = response.statusCode;
    // non std
    if (url) result.url = url;
    result.body = response.body;
    // Sometimes it's a string, sometimes it's already parsed. Talk to ODataJS...
    try {
      result.body = JSON.parse(result.body);
    }
    catch(e) {}
    if (result.body) {
      try {
        var msg = getMessage(result.body.error);
        if (msg.length > 0) {
          result.message = msg;
        }
      }
      catch (e) { }
    }
    proto._catchNoConnectionError(result);
    return result;
  }

  function getMessage(body) {
    var msg = body.message || "";
    return ((typeof (msg) === "string") ? msg : msg.value);
  }


  breeze.config.registerAdapter("dataService", ctor);


  var webApiODataCtor = function () {
    this.name = "webApiOData";
  };

  core.extend(webApiODataCtor.prototype, proto);

  webApiODataCtor.prototype.getRoutePrefix = function (dataService) {
    // Get the routePrefix from a Web API OData service name.
    // The routePrefix is presumed to be the pathname within the dataService.serviceName
    // Examples of servicename -> routePrefix:
    //   'http://localhost:55802/odata/' -> 'odata/'
    //   'http://198.154.121.75/service/odata/' -> 'service/odata/'
    var parser;
    if (typeof document === 'object') { // browser
      parser = document.createElement('a');
      parser.href = dataService.serviceName;
    } else { // node
      parser = url.parse(dataService.serviceName);
    }
    var prefix = parser.pathname;
    if (prefix[0] === '/') {
      prefix = prefix.substr(1);
    } // drop leading '/'  (all but IE)
    if (prefix.substr(-1) !== '/') {
      prefix += '/';
    }      // ensure trailing '/'
    return prefix;
  };

  
  breeze.config.registerAdapter("dataService", webApiODataCtor);
  // OData 4 adapter
  var webApiOData4Ctor = function () {
    this.name = "webApiOData4";
  };
  core.extend(webApiOData4Ctor.prototype, webApiODataCtor.prototype);
  webApiOData4Ctor.prototype.initialize = function () {
    // Aargh... they moved the cheese.
    var datajs = core.requireLib("datajs", "Needed to support remote OData v4 services");
    odatajs = datajs.V4.oData;
    odatajs.json.jsonHandler.recognizeDates = true;
  };
  webApiOData4Ctor.prototype.headers = { "OData-Version": "4.0" };
  breeze.config.registerAdapter("dataService", webApiOData4Ctor);

  // These data types are new in OData4
  DataType.Date = DataType.addSymbol({
    defaultValue: new Date(1900, 0, 1), isDate: true,
    parse: DataType.DateTime.parse,
    fmtOData: function (val) { return val.toISOString().substring(0, 10); /* YYYY-MM-DD is always 10 chars long */ },
    getNext: function () { return new Date(); },
    validatorCtor: breeze.Validator.date
  });
}, this));
